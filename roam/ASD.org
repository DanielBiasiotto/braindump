#+TITLE: Algoritmi e Strutture Dati
#+TEACHER: Andras Horvath(horvathATdi.unito.it)
[[file:#universita.org][#universita]]
Esame
- scritto
- discussione laboratorio

Libro
- Introduzione agli algoritmi e strutture dati

* Problemi e Algoritmi

** Problemi Computazionali
Collezione di domande (istanze-ingressi) per cui sia stabilito un criterio astratto per riconoscere le risposte (uscite) corrette
- Es
  - Massimo comune divisore
  - moltiplicazione fra due interi
  - fattorizzazione
  - ordinamento
  - percorso ottimo in un grafo

Un Problema e' una _Relazione Binaria_
$R = {(istanza,risposta) : istanza, risposta soddisfano...}$
Il _dominio_ della relazione e' l'insieme delle domande possibili
R e' _univoca_ se ogni istanza ammette una sola risposta

** Algoritmi
Metodo meccanico per risolvere un Problema Computazionale
- Procedura
  + produce un output da qualsiasi input
- Algoritmo
  + procedura che termina per ogni ingressa ammissibile

Un algoritmo e' detto deterministico se sulla stesso input fornisce sempre lo stesso output
- ad ogni algoritmo deterministico possiamo associare una finzione input-output

Un algoritmo risolve R, ossia e' corretto rispetto ad R, se la sua funzione A associa una risposta ad ogni istanza di R

Un programma imlementa piu' algoritmi, inoltre implementa opportune strutture dati

** Peak Finding
Input: vettore A[0...n-1] interi positivi
Output: un intero 0<= p <n t.c. A[p-1]<=A[p]>=A[p+1] dove A[-1]=A[n]=-inf

Peak(A)
for(i=0;i<length(A);i++)
    if(A[i]>=A[i-1] && A[i]>=A[i+1])
        return i
end for

*** Left Peak Finding
Nel caso migliore p=0 e' un picco
Nel caso peggiore p=n-1 confronti
*** Max Peak Finding
MAX-PEAK(A)
r = 0
i = 1
while(i<n-1)
    if A[i] > A[r]
        r <- i
    i <- i+1
end while
return r

Fa sempre lo stesso numero di confronti, sempre n-1

*** Analisi
Teorema picco
Si trovano segmenti sempre piu' corti su cui vale il teorema a partire da un q centrale.

*** Divide et Impera
PEAK-DI
p<-(i+j)/2
if A[p-1]<=A[p]>=A[p+1] then
    return p
else
    if A[p-1]>A[p] then
        return PEAK-DI(A,i,p-1)
    else
        return PEAK-DI(A,p+1,j)
    endif
endif

PEAK-FIND-DI(A,n)
return PEAK-DI(A,0,n-1)

- T(n)=
  - 1;        n=1
  - T(n/2)+1; n>1
$T(n)=T(\frac{n}{2^k})+k$ per $1\le k \le \log_{2}n$
$T(n)=1+\log_{2}n$
** Insolubilita' e Intrattabilita'
non tutti i problemi hanno una soluzione algoritmica (problema della terminazione)

intrattabile e' un problema che ha una soluzione algoritmica ma lo sforzo computazionale e' troppo grande

** Correttezza
Totale e Parziale

Specifica
- Precondizioni
- Postcondizioni
  - criterio che stabilisce come deve essere fatto l'output
**** Ricorsione
Un problema si presta alla ricorsione quando la ricorsione con un certo input ha una relazione semplice con la soluzione del problema con uno o piu' input diminuiti
#+begin_example
HANOI(n,solgente,destinazione,appoggio)
PRE:
- n>0
- base degli n dischi in alto ha diametro piu' piccolo del disco piu' in alto sia di destinazione che di appoggio
POST:
- torre di n dischi piu' in alto su sorgente e' spostata su destinazione

if n-1 then
    sposta un disco da sorgente a destinazione
else
    HANOI(n-1, sorgente, appoggio, destinazione)
    sposta un disco da solgente a destinazione
    HANOI(n-1, appoggio, destinazione, sorgente)
endif
#+end_example
#+begin_example
DIV-REC(a,b)
- Pre: a ge 0, b > 0
- Post: q, r t.c. a eq bq + r AND 0 le r < b
if a < b then
    q,r <- 0,a
else
    q',r <- DIV-REC(a-b,b)
    q <- q'+1
end if
return q,r
#+end_example
***** Schema dell'induzione semplice
1. Caso base P(1)
2. Passo induttivo P(m+1), P(m) e' l'ipotesi induttiva
3. 1. e 2. implicano che $\forall n \ge 1, P(n)$
***** Schema dell'induzione completa
1. Caso base $$
2. Passo induttivo
3. Conclusione
