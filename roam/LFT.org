#+TITLE: Linguaggi Formali e Traduttori
#+COURSE: LFT A
#+TEACHER: Sproston Jeremy
[[file:20201016001635-universita.org][#universitá]]



Informazioni varie del Corso:
- Lunedi' lezione sincrona per domande: 11:00

- Prova scritta + orale facoltativo (necassario per la lode)
  2/3 del voto

- Prova di laboratorio (progetto, interrogazione singola - anche in caso di progetto di gruppo con gruppi da 3) - Sostenibile dopo aver superato Teoria
  1/3 del voto
 
* Testi

** Compilatori
Principi tecniche e strumenti

** Automi
Automi, Linguaggi e Calcolabilita'

* Fasi Compilatore

** Analisi Lessicale

** Analisi Sintattica

** Analisi Semantica _Non affrontata nel corso_

* Automi

** Automi a stati finiti deterministici =DFA=
Deterministico: lo stato in cui si sposta e' univocamente determinato dallo stato corrente e dal input

Quintupla composta da:
1. \(Q\) - insieme finito di stati
2. \(Sigma\) - alfabeto riconosciuto
3. \(delta\) - funzione di transizione
4. \(q_{0}\) - e' lo stato iniziale
5. \(F\) - insieme di stati finali

** Funzione di transizione estesa
funzione definita su stringhe invece che singoli simboli
definito per induzione
** Linguaggio riconosciuto
Stringhe definite sull'alfabeto che per mezzo della F di transizione estesa portano ad uno =stato finale= dell'automa
*** Linguaggio regolare
Esiste almeno un Automa A che lo riconosce
** Esempio
automa: riconosce stringhe
stati finiti: memoria finita
input: stringa
output: "si" se riconosciuta "no" altrimenti

L'automa ha visione =locale e limitata= | legge un simbolo alla volta

L'automa altera il suo stato in base al simbolo letto

Se alla fine della stringa l'automa si trova in uno =stato finale= l'output sara' "si", altrimenti "no"

** Automi a stati finiti non deterministici =NFA=
Non deterministico: l'automa puo' scegliere di spostarsi in 0 o piu' stati possibili
- Il codominio della funzione di transizione e' l'insieme delle parti degli stati Q
Quintupla composta da:
1. \(Q\) - insieme finito di stati
2. \(\Sigma\) - alfabeto riconosciuto
3. \(\delta\) - funzione di transizione il cui codominio e' un'insieme delle parti di Q
4. \(q_0\) - e' lo stato iniziale
5. \(F\) - insieme di stati finali

   Insiemi singoletto indicano transizioni deterministiche (da funzione di transizione estesa)ilon-transizioni
   Automi che possono eseguire transizioni spontanee senza leggere alcun simbolo nella stringa da riconoscere
   - passa di stato anche senza consumare alcun simbolo

*** epsilon-chiusura
calcolare l'insieme di stati raggiungibili solo con transizioni-epsilon
=ECLOSE=
- la chiusura e' transitiva
- la chiusura di q include q
  ECLOSE(S) = Unione di ECLOSE(q_i)

  Gli NFA sono un caso particolare di epsilon-NFA in cui non ci sono transizioni epsilon
  + il potere riconoscitivo degli epsilon-NFA e' _almeno_ pari a quello dei DFA/NFA

**** Teorema
:PROPERTIES:
:ID:       620e4246-6e0d-4be2-899e-b7d92678a0c0
:END:
Dato un eNFA E esiste un DFA D tale che L(D) = L(E)
** Passaggio da =DFA= a =NFA= e viceversa

Da NFA a DFA sono possibili ~fino~ a \(2^n\) stati

Da un DFA con piu' stati finali e' possibile ricavare un e-NFA equivalente con un unico stato finale

** Espressioni regolari =RE=
Sono un approccio generativo alle classi di Linguaggi
E' sempre possibile creare un e-NFA a partire da una RE

Denotano un Linguaggio con
L(E)
Definito per induzione

L(0) = 0
L(epsilon) = {epsilon} // la stringa vuota
L(a) = {a}
L(E+F) = L(E) U L(F)
L(EF) = L(E)L(F)
L(E*) = L(E)*   // chiusura di Kleene
*** precedenza
1. *
2. concatenazione
3. +

*** Proprieta'


**** Unione
- Commutativa
- Associativa
- Idempotenza
- Identita

**** Concatenazione
- Associativa
- Identita'
- Assorbimento
- distributivita'
**** Chiusura di Kleene
- Idempotenza

** Linguaggi Regolari
=def= Un Linguaggio riconoscibile da un =DFA=
*** I linguaggi regolari sono chiusi rispetto all'operazione di unione
'Collego' i due automi deterministici attraverso uno stato q0 che con epsilon-transizioni passa da uno o dall'altro

*** I linguaggi regolari sono chiusi rispetto all'operazione di concatenazione
'Collego' lo stato finale (che non sara' piu' finale) del e-NFA corrispondente al primo automa con quello iniziale di quello e-NFA del successivo, con una epsilon-transizione

*** Chiusura #dim
*** \(L\cup L^{'}\)
+ Dati \(E_{1}\) e \(E_{2}\)
  - Si dimostra che \(E_{1}+E{_2}\) genera \(L\cupL^{'}\)
  - Essendo quella ancora un'espressione regolare anche il linguaggio generato sará regolare
*** \(LL^{'}\)
+ Simile all'unione
*** \(not{L}\)
+ \(not{L}= \Sigma^{*}-L\)
+ si crea un automa \(B = (Q,\Sigma,\delta,q_{0},Q-F)\)
  - abbiamo complementato l'insieme degli stati finali
*** i\(L\cap L^{'}\)
+ Si utilizzano le leggi di De Morgan
  - ci si riconduce al caso dell'unione e della complementazione
+ O si construisce un automa \(B\) che riconosce una simulazione dei due automi iniziali \(A_1\) e \(A_2\)
*** \(L -L^{'}\)
+ \(L_1 - L_2 = L_1 \cap notL_2\)
*** \(L^{R}\)
+ L rovesciato
+ Si ricava un \(E^R\) per induzione
  \(\o^R=\o\)
  \(\epsilon^R=\epsilon\)
  \(a^R=a\)
  \((E_1+E_2)^R={E_1}^R+{E_2}^R\)
  \((E_1 E_2)^R = {E_2}^R {E_1}^R\)
  \((E^*)^R = (E^R)^*\)
  Facile poi dimostrare che \(L(E^R) = L(E)^R\)
  Tutti questi sono ancora regolari

** Linguaggi non Regolari
*** Pumping Lemma
Per ogni linguaggio regolare \(L\) esiste \(n\) appartenente a \(N\) tale che per ogni \(w\) appartenente a \(L\) con \(|w|>= n\) esistono \(x,y,z\) tc \(w=xyz\) :
1. \(y!=\epsilon\)
2. \(|xy|<=n\)
3. \(xy^kz\) appartiene \(L\) per ogni \(k>=0\)
   Abbiamo una stringa media \(y\) non vuota che puó essere replicata un numero arbitrario di volte sempre ottenendo un Liguaggio Regolare.

   * Esempio
     + \(L=\{a^kb^k \mid k >= 0\}\) non é regolare
**** dim
*** \(L\) regolare
*** \(A = (Q,\Sigma,\delta,q_0,F)\) tc \(L=L(A)\)
*** \(n=|Q|\)
*** \(|w|>=n\) tc \(w=a_1a_2...a_m\) con \(m>=n\)
*** Dopo \(m\) passaggi lo stato \(q_m\) deve essere finale per definizione
*** Il numero di stati attraversati sará \(m+1\)
*** \(m>=n\) implica \(m+1>n\) quindi gli stati attraversati non possono essere tutti distinti
*** \(q_i =q_j\) e \(i<j\) é il primo stato che si ripete nel cammino dell'automa
Allora concludiamo identificando \(x,y,z\)
*** \(x=a_1a_2...a_i\)
*** \(y=a_{i+1}a_{i+2}...a_j\)
*** \(z=a_{j+1}a_{j+2}...a_m\)
1. \(y!=\epsilon\) in quanto \(i<j\)
2. \(|xy|<=n\) in quanto \(q_i=q_j\) é il primo stato che si ripete e sono al massimo \(n+1\)
3. \(xy^kz\) appartiene a \(L\) per ogni \(k>=0\)

** Indistinguibilitá tra stati
    =Equivalenza= (relazione riflessiva, simmetrica e transitiva)
    Due stati hanno lo stesso protere discriminante se presa una qualunque stringa del linguaggio si arriva ad uno stato finale in entrambi i casi o meno in entrambi i casi, la indichiamo con la tilde
    - Puó esserci una stringa che =distingue= i due stati
    - Uno stato finale é distinto da altri stati non finali dalla stringa vuota

*** Minimizzazione di Automi
    si raggiunge un automa minimo:
    \((Q/\tilde,\Sigma,\delta,[q_0],F/\tilde)\)
    in cui
    \(\delta([p],a)=[\delta(p,a)]\)
    Non esiste un automa corrispondente con meno stati dell'automa minimo

*** Equivalenza di Automi
    Puó essere usato l'algoritmo riempi tabella per decidere se due automi sono equivalente
    Si crea l'unione dei due DFA:
    \(A = (Q_1 \cup Q_2, \Sigma, \delta, q_1, F_1 \cup F_2)\)
    \(\delta(q,a) = \delta_1 \cup \delta_2
    Se $q_1$ e $q_2$ risultano indistinguibili in $A$ allora $A_1$ e $A_2$ sono _equivalenti_

** Linguaggi Liberi dal Contesto
   Le grammatiche libere sono un approccio generativo alle stringhe
   \(L = {a^nb^n \mid n \in \N}\) non e' regolare:
   - e' il inguaggio delle parentesi bilanciate

    \(G=(V,T,P,S)\) e' una =grammatica= libera
     - \(V\) variabili o simboli non terminali
     - $T$ terminali
     - $P$ produzioni \(A\to \alpha\)
       + testa
       + corpo
        La riscrittura della \(A\) in \(\alpha\)(sequenza arbitraria di simboli terminali o non) e' libera dal contesto
     - $S$ simbolo iniziale

     Derivazioni:
   - derivazione in un solo passo

   - derivazione in zero o piu' passi
        ne

    Il potere riconoscitivo delle grammatiche libere e' almeno tanto quanto quello dei linguaggi regolari

* Analisi Lessicale
sequenze di caratteri | =token= o =lessemi=

Si passa da
1. Programma come sequenza di caratteri
2. Programma come sequenza di token
** Token
Costante numerica intera
sequenza non vuota di cifre decimali, preceduta da + o -
Costante numerica con virgola
due sequenza (almeno 1 non vuota) di cifre decimali separate da .
Identificatore
sequenza on vuota di lettere numeri e _ e non inizia con un numero
** Lexer
=Analizzatore lessicale=
La visione del programma passa da "carattere per carattere" a "token per token"
- spazi e commenti vengono scartati dal lexer

