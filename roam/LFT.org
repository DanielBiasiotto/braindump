#+TITLE: Linguaggi Formali e Traduttori
#+COURSE: LFT A
#+TEACHER: Sproston Jeremy
<<<<<<< HEAD
#+startup: latexpreview
[[file:20201016001635-universita.org][#universitá]]
=======
[[file:#universita.org][#universitá]]
>>>>>>> 74e75ebd8fe4cc2f57b733ba168b84613c120970



Informazioni varie del Corso:
- Lunedi' lezione sincrona per domande: 11:00

- Prova scritta + orale facoltativo (necassario per la lode)
  2/3 del voto

- Prova di laboratorio (progetto, interrogazione singola - anche in caso di progetto di gruppo con gruppi da 3) - Sostenibile dopo aver superato Teoria
  1/3 del voto
 
* Testi

** Compilatori
Principi tecniche e strumenti

** Automi
Automi, Linguaggi e Calcolabilita'

* Fasi Compilatore

** Analisi Lessicale

** Analisi Sintattica

** Analisi Semantica _Non affrontata nel corso_
<<<<<<< HEAD
=======

* Analisi Lessicale
sequenze di caratteri | =token= o =lessemi=

Si passa da
1. Programma come sequenza di caratteri
2. Programma come sequenza di token
** Token
Costante numerica intera
sequenza non vuota di cifre decimali, preceduta da + o -
Costante numerica con virgola
due sequenza (almeno 1 non vuota) di cifre decimali separate da .
Identificatore
sequenza on vuota di lettere numeri e _ e non inizia con un numero
** Lexer
=Analizzatore lessicale=
La visione del programma passa da "carattere per carattere" a "token per token"
- spazi e commenti vengono scartati dal lexer
>>>>>>> 74e75ebd8fe4cc2f57b733ba168b84613c120970

* Automi

** Automi a stati finiti deterministici =DFA=
Deterministico: lo stato in cui si sposta e' univocamente determinato dallo stato corrente e dal input

Quintupla composta da:
1. \(Q\) - insieme finito di stati
2. \(Sigma\) - alfabeto riconosciuto
3. \(delta\) - funzione di transizione
4. \(q_{0}\) - e' lo stato iniziale
5. \(F\) - insieme di stati finali

** Funzione di transizione estesa
funzione definita su stringhe invece che singoli simboli
definito per induzione
** Linguaggio riconosciuto
Stringhe definite sull'alfabeto che per mezzo della F di transizione estesa portano ad uno =stato finale= dell'automa
** Linguaggio regolare
Esiste almeno un Automa A che lo riconosce
** Esempio
automa: riconosce stringhe
stati finiti: memoria finita
input: stringa
output: "si" se riconosciuta "no" altrimenti

L'automa ha visione =locale e limitata= | legge un simbolo alla volta

L'automa altera il suo stato in base al simbolo letto

Se alla fine della stringa l'automa si trova in uno =stato finale= l'output sara' "si", altrimenti "no"

** Automi a stati finiti non deterministici =NFA=
Non deterministico: l'automa puo' scegliere di spostarsi in 0 o piu' stati possibili
- Il codominio della funzione di transizione e' l'insieme delle parti degli stati Q
Quintupla composta da:
1. \(Q\) - insieme finito di stati
2. \(\Sigma\) - alfabeto riconosciuto
3. \(\delta\) - funzione di transizione il cui codominio e' un'insieme delle parti di Q
4. \(q_0\) - e' lo stato iniziale
5. \(F\) - insieme di stati finali

   Insiemi singoletto indicano transizioni deterministiche (da funzione di transizione estesa)ilon-transizioni
   Automi che possono eseguire transizioni spontanee senza leggere alcun simbolo nella stringa da riconoscere
   - passa di stato anche senza consumare alcun simbolo

*** epsilon-chiusura
calcolare l'insieme di stati raggiungibili solo con transizioni-epsilon
=ECLOSE=
- la chiusura e' transitiva
- la chiusura di q include q
  ECLOSE(S) = Unione di ECLOSE(q_i)

  Gli NFA sono un caso particolare di epsilon-NFA in cui non ci sono transizioni epsilon
  + il potere riconoscitivo degli epsilon-NFA e' _almeno_ pari a quello dei DFA/NFA

**** Teorema
:PROPERTIES:
:ID:       620e4246-6e0d-4be2-899e-b7d92678a0c0
:END:
Dato un eNFA E esiste un DFA D tale che L(D) = L(E)
** Passaggio da =DFA= a =NFA= e viceversa

Da NFA a DFA sono possibili ~fino~ a \(2^n\) stati

Da un DFA con piu' stati finali e' possibile ricavare un e-NFA equivalente con un unico stato finale

** Espressioni regolari =RE=
Sono un approccio generativo alle classi di Linguaggi
E' sempre possibile creare un e-NFA a partire da una RE

Denotano un Linguaggio con
L(E)
Definito per induzione

L(0) = 0
L(epsilon) = {epsilon} // la stringa vuota
L(a) = {a}
L(E+F) = L(E) U L(F)
L(EF) = L(E)L(F)
L(E*) = L(E)*   // chiusura di Kleene
*** precedenza
1. *
2. concatenazione
3. +

*** Proprieta'


**** Unione
- Commutativa
- Associativa
- Idempotenza
- Identita

**** Concatenazione
- Associativa
- Identita'
- Assorbimento
- distributivita'
**** Chiusura di Kleene
- Idempotenza

** Linguaggi Regolari
=def= Un Linguaggio riconoscibile da un =DFA=
*** I linguaggi regolari sono chiusi rispetto all'operazione di unione
'Collego' i due automi deterministici attraverso uno stato q0 che con epsilon-transizioni passa da uno o dall'altro

*** I linguaggi regolari sono chiusi rispetto all'operazione di concatenazione
'Collego' lo stato finale (che non sara' piu' finale) del e-NFA corrispondente al primo automa con quello iniziale di quello e-NFA del successivo, con una epsilon-transizione

*** Chiusura #dim
<<<<<<< HEAD
- \(L\cup L^{'}\)
+ Dati \(E_{1}\) e \(E_{2}\)
  - Si dimostra che \(E_{1}+E{_2}\) genera \(L\cupL^{'}\)
  - Essendo quella ancora un'espressione regolare anche il linguaggio generato sará regolare
- \(LL^{'}\)
+ Simile all'unione
- \(not{L}\)
+ \(not{L}= \Sigma^{*}-L\)
+ si crea un automa \(B = (Q,\Sigma,\delta,q_{0},Q-F)\)
  - abbiamo complementato l'insieme degli stati finali
- i\(L\cap L^{'}\)
+ Si utilizzano le leggi di De Morgan
  - ci si riconduce al caso dell'unione e della complementazione
+ O si construisce un automa \(B\) che riconosce una simulazione dei due automi iniziali \(A_1\) e \(A_2\)
- \(L -L^{'}\)
+ \(L_1 - L_2 = L_1 \cap notL_2\)
- \(L^{R}
  - L rovesciato
- Si ricava un \(E^R\) per induzione
=======
*** \(L\cup L^{'}\)
+ Dati \(E_{1}\) e \(E_{2}\)
  - Si dimostra che \(E_{1}+E{_2}\) genera \(L\cupL^{'}\)
  - Essendo quella ancora un'espressione regolare anche il linguaggio generato sará regolare
*** \(LL^{'}\)
+ Simile all'unione
*** \(not{L}\)
+ \(not{L}= \Sigma^{*}-L\)
+ si crea un automa \(B = (Q,\Sigma,\delta,q_{0},Q-F)\)
  - abbiamo complementato l'insieme degli stati finali
*** i\(L\cap L^{'}\)
+ Si utilizzano le leggi di De Morgan
  - ci si riconduce al caso dell'unione e della complementazione
+ O si construisce un automa \(B\) che riconosce una simulazione dei due automi iniziali \(A_1\) e \(A_2\)
*** \(L -L^{'}\)
+ \(L_1 - L_2 = L_1 \cap notL_2\)
*** \(L^{R}\)
+ L rovesciato
+ Si ricava un \(E^R\) per induzione
>>>>>>> 74e75ebd8fe4cc2f57b733ba168b84613c120970
  \(\o^R=\o\)
  \(\epsilon^R=\epsilon\)
  \(a^R=a\)
  \((E_1+E_2)^R={E_1}^R+{E_2}^R\)
  \((E_1 E_2)^R = {E_2}^R {E_1}^R\)
  \((E^*)^R = (E^R)^*\)
  Facile poi dimostrare che \(L(E^R) = L(E)^R\)
  Tutti questi sono ancora regolari

** Linguaggi non Regolari
*** Pumping Lemma
Per ogni linguaggio regolare \(L\) esiste \(n\) appartenente a \(N\) tale che per ogni \(w\) appartenente a \(L\) con \(|w|>= n\) esistono \(x,y,z\) tc \(w=xyz\) :
1. \(y!=\epsilon\)
2. \(|xy|<=n\)
3. \(xy^kz\) appartiene \(L\) per ogni \(k>=0\)
   Abbiamo una stringa media \(y\) non vuota che puó essere replicata un numero arbitrario di volte sempre ottenendo un Liguaggio Regolare.

   * Esempio
     + \(L=\{a^kb^k \mid k >= 0\}\) non é regolare
**** dim
<<<<<<< HEAD
- \(L\) regolare
- \(A = (Q,\Sigma,\delta,q_0,F)\) tc \(L=L(A)\)
- \(n=|Q|\)
- \(|w|>=n\) tc \(w=a_1a_2...a_m\) con \(m>=n\)
- Dopo \(m\) passaggi lo stato \(q_m\) deve essere finale per definizione
- Il numero di stati attraversati sará \(m+1\)
- \(m>=n\) implica \(m+1>n\) quindi gli stati attraversati non possono essere tutti distinti
- \(q_i =q_j\) e \(i<j\) é il primo stato che si ripete nel cammino dell'automa
Allora concludiamo identificando \(x,y,z\)
- \(x=a_1a_2...a_i\)
- \(y=a_{i+1}a_{i+2}...a_j\)
- \(z=a_{j+1}a_{j+2}...a_m\)
1. \(y!=\epsilon\) in quanto \(i<j\)
2. \(|xy|<=n\) in quanto \(q_i=q_j\) é il primo stato che si ripete e sono al massimo \(n+1\)
3. \(xy^kz\) appartiene a \(L\) per ogni \(k>=0\)

** Indistinguibilitá tra stati
    =Equivalenza= (relazione riflessiva, simmetrica e transitiva)
    Due stati hanno lo stesso protere discriminante se presa una qualunque stringa del linguaggio si arriva ad uno stato finale in entrambi i casi o meno in entrambi i casi, la indichiamo con la tilde
    - Puó esserci una stringa che =distingue= i due stati
    - Uno stato finale é distinto da altri stati non finali dalla stringa vuota

*** Minimizzazione di Automi
    si raggiunge un automa minimo:
    \((Q/\tilde,\Sigma,\delta,[q_0],F/\tilde)\)
    in cui
    \(\delta([p],a)=[\delta(p,a)]\)
    Non esiste un automa corrispondente con meno stati dell'automa minimo

*** Equivalenza di Automi
    Puó essere usato l'algoritmo riempi tabella per decidere se due automi sono equivalente
    Si crea l'unione dei due DFA:
    \(A = (Q_1 \cup Q_2, \Sigma, \delta, q_1, F_1 \cup F_2)\)
    \(\delta(q,a) = \delta_1 \cup \delta_2
    Se $q_1$ e $q_2$ risultano indistinguibili in $A$ allora $A_1$ e $A_2$ sono _equivalenti_

** Linguaggi Liberi dal Contesto
   Le grammatiche libere sono un approccio generativo alle stringhe
   \(L = {a^nb^n \mid n \in \N}\) non e' regolare:
   - e' il inguaggio delle parentesi bilanciate

    \(G=(V,T,P,S)\) e' una =grammatica= libera
     - \(V\) variabili o simboli non terminali
     - $T$ terminali
     - $P$ produzioni \(A\to \alpha\)
       + testa
       + corpo
        La riscrittura della \(A\) in \(\alpha\)(sequenza arbitraria di simboli terminali o non) e' libera dal contesto
     - $S$ simbolo iniziale

     =Derivazioni=:
   - derivazione in un solo passo
   - derivazione in zero o piu' passi

    Il potere riconoscitivo delle grammatiche libere e' almeno tanto quanto quello dei linguaggi regolari

    =Derivazioni canoniche=
     - leftmost
       + $\Rightarrow_{lm}$

     - rightmost
       + $\Rightarrow_{rm}$

     Se esistono due derivazioni canoniche distinte (entrambe lm o rm) per la stessa stringa allora $G$ e' ambigua

*** Alberi Sintattici
    Derivazioni differenti possono generare lo stesso programma
    - anche imponendo regole all'ordine delle riscritture

    Gli alberi sintattici (alternativa alle generazioni) astraggono dall'ordine delle riscritture e permettono di ragionare sulla =struttura= delle stringhe
    - grammatiche ambigue
      + piu' alberi con lo stesso prodotto
      + non e' avere derivazioni distente che mi porta ad alberi diversi e quindi ambiguita'
    Data una grammatica $G = (V,T,P,S)$ gli alberi sintattici di $G$:
    - ogni nodo etichettato con una var in $V$
    - ogni foglia etichettata da $V$ o $T$ o $\epsilon$
    - $\epsilon$ significa unico figlio del genitore
    - se un nodo $A$ i suoi figli sono etichettati (sx a dx)
      + $X_{1},X_{2},...,X_{n}$
      + $A\to X_{1},X_{2},...,X_{n}$ e' una produzione in $P$
    Il =prodotto= e' la stringa ottenuta cocatenando(sx verso dx) le etichette di tutte le foglie

**** Teorema
    $A\to G* \alpha$ se e solo se esiste un albero sintattico di $G$ con radice $A$ e prodotto $\alpha$

**** Risoluzione delle ambiguitá (grammatiche in forma infissa)
   - Precedenza degli operatori
   - Associativitá degli operatori
     + per operatori associativi questo non é un problema
     + lo é per altri operatori

Soluzione ad hoc
    Utilizziamo associativitá a sinistra, sbilanciamo le espressioni e le stratifichiamo
   - Espressione = somma di termini
   - Termine = prodotto di fattori
   - Fattore = costante o espressione tra parentesi

Nuova grammatica:
    $(\{E,T,F\},\{0,1,...,9,+,*,(,)\},P,E)$
    Produzioni:
    - $E\to T\midE+T$
    - $T\to\midT*F$
    - $F\to0\mid1\mid...\mid9\mid(E)$

**** Linguaggi inerentemente ambigui

** Automi a Pila =PDA=
=Approccio Riconoscitivo=
    Utilizza operazioni push e pop su una pila di dimensione illimitata

    - Simbolo sentinella $Z_{0}$ che indica la fine della stringa, é il simbolo della pila con cui quest'ultima viene inizializzata
    - Ad ogni lettura di un simbolo l'automa fa push(x) o push(b) dipendentemente dal Linguaggio
    - La $\epsilon$ transizione finale puó eseguire solo se peek restituisce $Z_{0}$

    $P=(Q,\Sigma,\Gamma,\delta,q_{0},Z_{0},F)$
    - \(\Sigma\) = alfabeto di input
    - \(\Gamma\) = alfabeto della pila
    - \(\delta:Q\times(\Sigma\cup\{\epsilon\})\times\Gamma \to p(Q\times\Gamma^{*})\) = funzione di transizione

*** Descrizioni istantanee
    Fissato un automa a pila $P$
    $D.I.=(q,w,\alpha)$
    - stato in cui si trova l'automa
    - ció che rimane dariconoscere nella stringa di input
    - contenuto della pila dalla cima al fondo (sx a dx)

**** Mosse
    relazioni da $D.I.$ a $D.I.$
    $I\vdash_{P}J$
    chiusura riflessiva e transitiva
    $I\vdash^{*}_{P}J$

*** Linguaggio Accettato
Per stato finale:
    $L(P) = \{w\in\Sigma^{*}\mid(q_{0},w,Z_{0})\vdash_{P}^{*}(q,\epsilon,\alpha), q\in F\}$
Per pila vuota:
    $N(P)=\{w\in\Sigma^{*}\mid(q_{0},w,Z_{0})\vdash^{*}_{P}(q,\epsilon,\epsilon)\}$
- Per stato finale il contenuto della pila nella \(D.I.\) finale é irrilevante
- Per pila vuoto lo stato nela \(D.I.\) finale puó non essere finale

In ogni caso la stringa di input deve essere consumata completamente

* Analisi Lessicale
sequenze di caratteri | =token= o =lessemi=

Si passa da
1. Programma come sequenza di caratteri
2. Programma come sequenza di token
** Token
Costante numerica intera
sequenza non vuota di cifre decimali, preceduta da + o -
Costante numerica con virgola
due sequenza (almeno 1 non vuota) di cifre decimali separate da .
Identificatore
sequenza on vuota di lettere numeri e _ e non inizia con un numero
** Lexer
=Analizzatore lessicale=
La visione del programma passa da "carattere per carattere" a "token per token"
- spazi e commenti vengono scartati dal lexer

=======
*** \(L\) regolare
*** \(A = (Q,\Sigma,\delta,q_0,F)\) tc \(L=L(A)\)
*** \(n=|Q|\)
*** \(|w|>=n\) tc \(w=a_1a_2...a_m\) con \(m>=n\)
*** Dopo \(m\) passaggi lo stato \(q_m\) deve essere finale per definizione
*** Il numero di stati attraversati sará \(m+1\)
*** \(m>=n\) implica \(m+1>n\) quindi gli stati attraversati non possono essere tutti distinti
*** \(q_i =q_j\) e \(i<j\) é il primo stato che si ripete nel cammino dell'automa
Allora concludiamo identificando \(x,y,z\)
*** \(x=a_1a_2...a_i\)
*** \(y=a_{i+1}a_{i+2}...a_j\)
*** \(z=a_{j+1}a_{j+2}...a_m\)
1. \(y!=\epsilon\) in quanto \(i<j\)
2. \(|xy|<=n\) in quanto \(q_i=q_j\) é il primo stato che si ripete e sono al massimo \(n+1\)
3. \(xy^kz\) appartiene a \(L\) per ogni \(k>=0\)
>>>>>>> 74e75ebd8fe4cc2f57b733ba168b84613c120970
